// AUTO-GENERATED BY build.rs

use parabit::*;

use ntest::timeout;


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_AddSub_1164() {
    let mut eq = Equivalence::new(
        "AddSub_1164",
        &[],
        "(bw k (+ (bw k (- (bw k 0) (bw k var_a))) (bw k var_b)))",
        "(bw k (- (bw k var_b) (bw k var_a)))",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_AddSub_1574() {
    let mut eq = Equivalence::new(
        "AddSub_1574",
        &[],
        "(bw k (- (bw k C) (bw k (+ (bw k var_X) (bw k C2)))))",
        "(bw k (- (bw k (- (bw k C) (bw k C2))) (bw k var_X)))",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_AddSub_1165() {
    let mut eq = Equivalence::new(
        "AddSub_1165",
        &[],
        "(bw k (+ (bw k (- (bw k 0) (bw k var_a))) (bw k (- (bw k 0) (bw k var_b)))))",
        "(bw k (- (bw k 0) (bw k (+ (bw k var_a) (bw k var_b)))))",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_muldivrem_290_292() {
    let mut eq = Equivalence::new(
        "muldivrem_290_292",
        &["(< (bw k var_Y) (bw k 4))"],
        "(bw k (* (bw k (<< (bw k 1) (bw k var_Y))) (bw k var_Op1)))",
        "(bw k (<< (bw k var_Op1) (bw k var_Y)))",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_InstCombineShift497d() {
    let mut eq = Equivalence::new(
        "InstCombineShift497d",
        &["(< (bw k C) (bw k 4))"],
        "(bw k (<< (bw k (+ (bw k var_X) (bw k C2))) (bw k C)))",
        "(bw k (+ (bw k (<< (bw k var_X) (bw k C))) (bw k (<< (bw k C2) (bw k C)))))",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_muldivrem_152() {
    let mut eq = Equivalence::new(
        "muldivrem_152",
        &[],
        "(bw k (* (bw k var_x) (bw k -1)))",
        "(bw k (- (bw k 0) (bw k var_x)))",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_AddSub_1539_2() {
    let mut eq = Equivalence::new(
        "AddSub_1539_2",
        &[],
        "(bw k (- (bw k var_x) (bw k C)))",
        "(bw k (+ (bw k var_x) (bw k (- (bw k C)))))",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_muldivrem_229() {
    let mut eq = Equivalence::new(
        "muldivrem_229",
        &[],
        "(bw k (* (bw k (+ (bw k var_X) (bw k C1))) (bw k var_Op1)))",
        "(bw k (+ (bw k (* (bw k var_X) (bw k var_Op1))) (bw k (* (bw k C1) (bw k var_Op1)))))",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_muldivrem_239() {
    let mut eq = Equivalence::new(
        "muldivrem_239",
        &[],
        "(bw k (* (bw k (- (bw k 0) (bw k var_X))) (bw k (- (bw k 0) (bw k var_Y)))))",
        "(bw k (* (bw k var_X) (bw k var_Y)))",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_AddSub_1614() {
    let mut eq = Equivalence::new(
        "AddSub_1614",
        &[],
        "(bw k (- (bw k var_X) (bw k (+ (bw k var_X) (bw k var_Y)))))",
        "(bw k (- (bw k 0) (bw k var_Y)))",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_AddSub_1176() {
    let mut eq = Equivalence::new(
        "AddSub_1176",
        &[],
        "(bw k (+ (bw k var_a) (bw k (- (bw k 0) (bw k var_b)))))",
        "(bw k (- (bw k var_a) (bw k var_b)))",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_AddSub_1619() {
    let mut eq = Equivalence::new(
        "AddSub_1619",
        &[],
        "(bw k (- (bw k (- (bw k var_X) (bw k var_Y))) (bw k var_X)))",
        "(bw k (- (bw k 0) (bw k var_Y)))",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_Select_1105() {
    let mut eq = Equivalence::new(
        "Select_1105",
        &[],
        "(bw k var_Y)",
        "(bw k var_Y)",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_arith_Select_1100() {
    let mut eq = Equivalence::new(
        "Select_1100",
        &[],
        "(bw k var_X)",
        "(bw k var_X)",
    );
    eq = eq.find_equivalence(&None);
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found.\n{}", eq.explanation_string());
    eq = eq.make_proof();
    let _expl = eq.explanation_string();
    // println!("{}", _expl); 
    // let _isabelle_proof = eq.to_isabelle(true);
    // #[cfg(feature = "isabelle-check")]
    // eq.check_proof(&output_dir).unwrap();
}

