// AUTO-GENERATED BY build.rs

use para_bit::*;

use std::path::PathBuf;

use ntest::timeout;


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_commutativity_add() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("commutativity_add");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "commutativity_add",
        &[],
        "(bw r ( + (bw p a) (bw q b)))",
        "(bw r ( + (bw q b) (bw p a)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_commutativity_mult() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("commutativity_mult");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "commutativity_mult",
        &[],
        "(bw r ( * (bw p a) (bw q b)))",
        "(bw r ( * (bw q b) (bw p a)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_mult_assoc_1() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("mult_assoc_1");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "mult_assoc_1",
        &["(>= q t)", "(>= u t)"],
        "(bw t ( * (bw u (* (bw p a) (bw r b))) (bw s c)))",
        "(bw t ( * (bw p a) (bw q (* (bw r b) (bw s c)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_mult_assoc_2() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("mult_assoc_2");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "mult_assoc_2",
        &["(>= q t)", "(<= (+ p r) u)"],
        "(bw t ( * (bw u (* (bw p a) (bw r b))) (bw s c)))",
        "(bw t ( * (bw p a) (bw q (* (bw r b) (bw s c)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_mult_assoc_3() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("mult_assoc_3");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "mult_assoc_3",
        &["(<= (+ r s) q)", "(>= u t)"],
        "(bw t ( * (bw u (* (bw p a) (bw r b))) (bw s c)))",
        "(bw t ( * (bw p a) (bw q (* (bw r b) (bw s c)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_mult_assoc_4() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("mult_assoc_4");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "mult_assoc_4",
        &["(<= (+ r s) q)", "(<= (+ p r) u)"],
        "(bw t ( * (bw u (* (bw p a) (bw r b))) (bw s c)))",
        "(bw t ( * (bw p a) (bw q (* (bw r b) (bw s c)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_add_assoc_1() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("add_assoc_1");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "add_assoc_1",
        &["(>= q t)", "(>= u t)"],
        "(bw t ( + (bw u (+ (bw p a) (bw r b))) (bw s c)))",
        "(bw t ( + (bw p a) (bw q (+ (bw r b) (bw s c)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_add_assoc_2() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("add_assoc_2");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "add_assoc_2",
        &["(< r q)", "(< s q)", "(>= u t)"],
        "(bw t ( + (bw u (+ (bw p a) (bw r b))) (bw s c)))",
        "(bw t ( + (bw p a) (bw q (+ (bw r b) (bw s c)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_add_assoc_3() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("add_assoc_3");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "add_assoc_3",
        &["(>= q t)", "(< p u)", "(< r u)"],
        "(bw t ( + (bw u (+ (bw p a) (bw r b))) (bw s c)))",
        "(bw t ( + (bw p a) (bw q (+ (bw r b) (bw s c)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_add_assoc_4() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("add_assoc_4");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "add_assoc_4",
        &["(< r q)", "(< s q)", "(< p u)", "(< r u)"],
        "(bw t ( + (bw u (+ (bw p a) (bw r b))) (bw s c)))",
        "(bw t ( + (bw p a) (bw q (+ (bw r b) (bw s c)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_dist_over_add() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("dist_over_add");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "dist_over_add",
        &["(>= q r)", "(>= u r)", "(>= v r)"],
        "(bw r (* (bw p a) (+ (bw s b) (bw t c))))",
        "(bw r (+ (bw u (* (bw p a) (bw s b))) (bw v (* (bw p a) (bw t c)) ) ))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_sum_same() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("sum_same");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "sum_same",
        &[],
        "(bw q (+ (bw p a) (bw p a)))",
        "(bw q (* (bw 2 2) (bw p a)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_mult_sum_same() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("mult_sum_same");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "mult_sum_same",
        &["(> t p)", "(> t 1)", "(>= s (+ p q))"],
        "(bw r (+ (bw s (* (bw p a) (bw q b))) (bw q b)))",
        "(bw r (* (bw t (+ (bw p a) (bw 1 1))) (bw q b)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_add_zero() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("add_zero");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "add_zero",
        &[],
        "(bw p (+ (bw p a) (bw q 0)))",
        "(bw p a)",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_sub_to_neg() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("sub_to_neg");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "sub_to_neg",
        &[],
        "(bw r (- (bw p a) (bw q b)))",
        "(bw r (+ (bw p a) (- (bw q b))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_mul_one() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("mul_one");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "mul_one",
        &[],
        "(bw p (* (bw p a) (bw q 1)))",
        "(bw p a)",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_mul_two() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("mul_two");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "mul_two",
        &[],
        "(bw r (* (bw p a) 2))",
        "(bw r (<< (bw p a) (bw 1 1)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_merge_left_shift() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("merge_left_shift");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "merge_left_shift",
        &["(>= u r)", "(> t s)", "(> t q)"],
        "(bw r (<< (bw u (<< (bw p a) (bw q b))) (bw s c)))",
        "(bw r (<< (bw p a) (bw t (+ (bw q b) (bw s c)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_merge_right_shift() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("merge_right_shift");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "merge_right_shift",
        &["(>= u p)", "(> t s)", "(> t q)"],
        "(bw r (>> (bw u (>> (bw p a) (bw q b))) (bw s c)))",
        "(bw r (>> (bw p a) (bw t (+ (bw q b) (bw s c)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_left_shift_add_1() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("left_shift_add_1");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "left_shift_add_1",
        &["(>= u r)", "(>= s r)"],
        "(bw r (<< (bw s (+ (bw p a) (bw q b))) (bw t c)))",
        "(bw r (+ (bw u (<< (bw p a) (bw t c))) (bw u (<< (bw q b) (bw t c)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_left_shift_add_2() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("left_shift_add_2");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "left_shift_add_2",
        &["(>= u r)", "(> s p)", "(> s q)"],
        "(bw r (<< (bw s (+ (bw p a) (bw q b))) (bw t c)))",
        "(bw r (+ (bw u (<< (bw p a) (bw t c))) (bw u (<< (bw q b) (bw t c)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_add_right_shift() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("add_right_shift");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "add_right_shift",
        &["(>= q t)", "(>= s (+ p (- (^ 2 u) 1)))", "(> v s)", "(> v t)"],
        "(bw r (+ (bw p a) (bw q (>> (bw t b) (bw u c)))))",
        "(bw r (>> (bw v (+ (bw s (<< (bw p a) (bw u c))) (bw t b))) (bw u c)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_left_shift_mult() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("left_shift_mult");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "left_shift_mult",
        &["(>= t r)", "(>= v r)"],
        "(bw r (<< (bw t (* (bw p a) (bw q b))) (bw u c)))",
        "(bw r (* (bw v (<< (bw p a) (bw u c))) (bw q b)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn rover_one_to_two_mult() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("rover")
        .join("one_to_two_mult");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "one_to_two_mult",
        &["(> q (+ p 2))", "(> q p)"],
        "(bw p (* (bw 1 1) (bw p x)))",
        "(bw p (- (bw q (* (bw 2 2) (bw p x))) (bw p x)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}

