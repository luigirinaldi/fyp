// AUTO-GENERATED BY build.rs

use parabit::*;

use std::path::PathBuf;

use ntest::timeout;


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2417() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2417");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2417",
        &[],
        "(bw k (xor (bw k (or (bw k (xor (bw k var_nx) (bw k -1))) (bw k var_y))) (bw k -1)))",
        "(bw k (and (bw k var_nx) (bw k (xor (bw k var_y) (bw k -1)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2587() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2587");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2587",
        &[],
        "(bw k (xor (bw k (and (bw k var_a) (bw k var_op1))) (bw k var_op1)))",
        "(bw k (and (bw k (xor (bw k var_a) (bw k -1))) (bw k var_op1)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2581() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2581");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2581",
        &[],
        "(bw k (xor (bw k (or (bw k var_a) (bw k var_op1))) (bw k var_op1)))",
        "(bw k (and (bw k var_a) (bw k (xor (bw k var_op1) (bw k -1)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2243() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2243");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2243",
        &[],
        "(bw k (or (bw k (and (bw k (or (bw k var_B) (bw k var_C))) (bw k var_A))) (bw k var_B)))",
        "(bw k (or (bw k var_B) (bw k (and (bw k var_A) (bw k var_C)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2367() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2367");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2367",
        &[],
        "(bw k (or (bw k (or (bw k var_A) (bw k C1))) (bw k var_op1)))",
        "(bw k (or (bw k (or (bw k var_A) (bw k var_op1))) (bw k C1)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2247() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2247");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2247",
        &[],
        "(bw k (or (bw k (xor (bw k var_A) (bw k -1))) (bw k (xor (bw k var_B) (bw k -1)))))",
        "(bw k (xor (bw k (and (bw k var_A) (bw k var_B))) (bw k -1)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2285() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2285");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2285",
        &[],
        "(bw k (or (bw k var_A) (bw k (xor (bw k (xor (bw k var_A) (bw k var_B))) (bw k -1)))))",
        "(bw k (or (bw k var_A) (bw k (xor (bw k var_B) (bw k -1)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2231() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2231");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2231",
        &[],
        "(bw k (or (bw k (xor (bw k var_A) (bw k var_B))) (bw k (xor (bw k (xor (bw k var_B) (bw k var_C))) (bw k var_A)))))",
        "(bw k (or (bw k (xor (bw k var_A) (bw k var_B))) (bw k var_C)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2123() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2123");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2123",
        &[],
        "(bw k (or (bw k (and (bw k var_A) (bw k (xor (bw k var_B) (bw k -1))))) (bw k (xor (bw k var_A) (bw k var_B)))))",
        "(bw k (xor (bw k var_A) (bw k var_B)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2284() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2284");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2284",
        &[],
        "(bw k (or (bw k var_A) (bw k (xor (bw k (or (bw k var_A) (bw k var_B))) (bw k -1)))))",
        "(bw k (or (bw k var_A) (bw k (xor (bw k var_B) (bw k -1)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2118() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2118");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2118",
        &[],
        "(bw k (or (bw k (and (bw k var_A) (bw k var_B))) (bw k (xor (bw k var_A) (bw k -1)))))",
        "(bw k (or (bw k (xor (bw k var_A) (bw k -1))) (bw k var_B)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2265() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2265");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2265",
        &[],
        "(bw k (or (bw k (and (bw k var_A) (bw k var_B))) (bw k (xor (bw k var_A) (bw k var_B)))))",
        "(bw k (or (bw k var_A) (bw k var_B)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_1230() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_1230");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_1230",
        &[],
        "(bw k (and (bw k (xor (bw k var_notOp0) (bw k -1))) (bw k (xor (bw k var_notOp1) (bw k -1)))))",
        "(bw k (xor (bw k (or (bw k var_notOp0) (bw k var_notOp1))) (bw k -1)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2113() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2113");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2113",
        &[],
        "(bw k (or (bw k (and (bw k (xor (bw k var_A) (bw k -1))) (bw k var_B))) (bw k var_A)))",
        "(bw k (or (bw k var_A) (bw k var_B)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2063() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2063");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2063",
        &[],
        "(bw k (or (bw k (xor (bw k var_x) (bw k C1))) (bw k C)))",
        "(bw k (xor (bw k (or (bw k var_x) (bw k C))) (bw k (and (bw k C1) (bw k (not (bw k C)))))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_135() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_135");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_135",
        &[],
        "(bw k (and (bw k (xor (bw k var_X) (bw k C1))) (bw k C2)))",
        "(bw k (xor (bw k (and (bw k var_X) (bw k C2))) (bw k (and (bw k C1) (bw k C2)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2416() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2416");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2416",
        &[],
        "(bw k (xor (bw k (and (bw k (xor (bw k var_nx) (bw k -1))) (bw k var_y))) (bw k -1)))",
        "(bw k (or (bw k var_nx) (bw k (xor (bw k var_y) (bw k -1)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2595() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2595");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2595",
        &[],
        "(bw k (xor (bw k (and (bw k var_a) (bw k var_b))) (bw k (or (bw k var_a) (bw k var_b)))))",
        "(bw k (xor (bw k var_a) (bw k var_b)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_1241() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_1241");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_1241",
        &[],
        "(bw k (and (bw k (or (bw k var_A) (bw k var_B))) (bw k (xor (bw k (and (bw k var_A) (bw k var_B))) (bw k -1)))))",
        "(bw k (xor (bw k var_A) (bw k var_B)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2607() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2607");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2607",
        &[],
        "(bw k (xor (bw k (or (bw k var_a) (bw k (xor (bw k var_b) (bw k -1))))) (bw k (or (bw k (xor (bw k var_a) (bw k -1))) (bw k var_b)))))",
        "(bw k (xor (bw k var_a) (bw k var_b)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2297() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2297");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2297",
        &[],
        "(bw k (or (bw k (and (bw k var_A) (bw k var_B))) (bw k (xor (bw k (xor (bw k var_A) (bw k -1))) (bw k var_B)))))",
        "(bw k (xor (bw k (xor (bw k var_A) (bw k -1))) (bw k var_B)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2627() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2627");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2627",
        &[],
        "(bw k (xor (bw k (xor (bw k var_a) (bw k var_c))) (bw k (or (bw k var_a) (bw k var_b)))))",
        "(bw k (xor (bw k (and (bw k (xor (bw k var_a) (bw k -1))) (bw k var_b))) (bw k var_c)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_1280() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_1280");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_1280",
        &[],
        "(bw k (and (bw k (or (bw k (xor (bw k var_A) (bw k -1))) (bw k var_B))) (bw k var_A)))",
        "(bw k (and (bw k var_A) (bw k var_B)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2430() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2430");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2430",
        &[],
        "(bw k (xor (bw k (or (bw k var_x) (bw k var_y))) (bw k -1)))",
        "(bw k (and (bw k (xor (bw k var_x) (bw k -1))) (bw k (xor (bw k var_y) (bw k -1)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2617() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2617");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2617",
        &[],
        "(bw k (xor (bw k (and (bw k var_a) (bw k (xor (bw k var_b) (bw k -1))))) (bw k (and (bw k (xor (bw k var_a) (bw k -1))) (bw k var_b)))))",
        "(bw k (xor (bw k var_a) (bw k var_b)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_1294() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_1294");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_1294",
        &[],
        "(bw k (and (bw k (or (bw k var_A) (bw k var_B))) (bw k (xor (bw k (xor (bw k var_A) (bw k -1))) (bw k var_B)))))",
        "(bw k (and (bw k var_A) (bw k var_B)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2647() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2647");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2647",
        &[],
        "(bw k (xor (bw k (and (bw k var_a) (bw k var_b))) (bw k (xor (bw k var_a) (bw k var_b)))))",
        "(bw k (or (bw k var_a) (bw k var_b)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2263() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2263");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2263",
        &[],
        "(bw k (or (bw k var_op0) (bw k (xor (bw k var_op0) (bw k var_B)))))",
        "(bw k (or (bw k var_op0) (bw k var_B)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2188() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2188");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2188",
        &[],
        "(bw k (or (bw k (and (bw k var_A) (bw k (xor (bw k var_D) (bw k -1))))) (bw k (and (bw k (xor (bw k var_A) (bw k -1))) (bw k var_D)))))",
        "(bw k (xor (bw k var_A) (bw k var_D)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2429() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2429");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2429",
        &[],
        "(bw k (xor (bw k (and (bw k var_x) (bw k var_y))) (bw k -1)))",
        "(bw k (or (bw k (xor (bw k var_x) (bw k -1))) (bw k (xor (bw k var_y) (bw k -1)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2264() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2264");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2264",
        &[],
        "(bw k (or (bw k var_A) (bw k (xor (bw k (xor (bw k var_A) (bw k -1))) (bw k var_B)))))",
        "(bw k (or (bw k var_A) (bw k (xor (bw k var_B) (bw k -1)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_1247() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_1247");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_1247",
        &[],
        "(bw k (and (bw k (xor (bw k (and (bw k var_A) (bw k var_B))) (bw k -1))) (bw k (or (bw k var_A) (bw k var_B)))))",
        "(bw k (xor (bw k var_A) (bw k var_B)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_2658() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_2658");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_2658",
        &[],
        "(bw k (xor (bw k (and (bw k var_a) (bw k (xor (bw k var_b) (bw k -1))))) (bw k (xor (bw k var_a) (bw k -1)))))",
        "(bw k (xor (bw k (and (bw k var_a) (bw k var_b))) (bw k -1)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_1253() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_1253");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_1253",
        &[],
        "(bw k (and (bw k (xor (bw k var_A) (bw k var_B))) (bw k var_A)))",
        "(bw k (and (bw k var_A) (bw k (xor (bw k var_B) (bw k -1)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_144() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_144");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_144",
        &[],
        "(bw k (and (bw k (or (bw k var_X) (bw k C1))) (bw k C2)))",
        "(bw k (and (bw k (or (bw k var_X) (bw k (and (bw k C1) (bw k C2))))) (bw k C2)))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}


#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn alive_bitwise_AndOrXor_1288() {
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("alive_bitwise")
        .join("AndOrXor_1288");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "AndOrXor_1288",
        &[],
        "(bw k (and (bw k (xor (bw k var_A) (bw k var_B))) (bw k (xor (bw k (xor (bw k var_B) (bw k var_C))) (bw k var_A)))))",
        "(bw k (and (bw k (xor (bw k var_A) (bw k var_B))) (bw k (xor (bw k var_C) (bw k -1)))))",
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}

