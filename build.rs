use std::fs::{self, File};
use std::io::Write;
use std::path::{Path, PathBuf};

include!("src/types.rs");

fn main() {
    let test_data_dir = Path::new("test_data");

    // Collect (name, path) tuples for all JSON files in test_data
    let mut files = Vec::new();

    if let Ok(entries) = fs::read_dir(test_data_dir) {
        for entry in entries {
            if let Ok(entry) = entry {
                let path = entry.path();
                if path.extension().and_then(|s| s.to_str()) == Some("json") {
                    if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                        let path_str = path.to_string_lossy().into_owned();
                        println!("cargo:rerun-if-changed={}", path_str);
                        files.push((file_stem.to_string(), path_str));
                    }
                }
            }
        }
    }

    for (prefix, file_path) in files {
        let out_path: PathBuf = format!("tests/{}.rs", prefix).into();
        let mut output = File::create(&out_path).expect("Failed to create output test file");

        writeln!(output, "// AUTO-GENERATED BY build.rs\n").unwrap();
        writeln!(output, "use hello_world::*;\n").unwrap(); // Replace `your_crate` with actual lib name
        writeln!(output, "use std::path::PathBuf;\n").unwrap();
        writeln!(output, "use ntest::timeout;\n").unwrap();
        let data = fs::read_to_string(&file_path)
            .unwrap_or_else(|_| panic!("Failed to read file {}", &file_path));
        let test_cases: Vec<EquivalenceString> =
            serde_json::from_str(&data).expect("Failed to parse JSON");

        for (_, case) in test_cases.iter().enumerate() {
            let fn_name = format!("{}_{}", prefix, case.name);
            let preconditions = format!("{:?}", case.preconditions);

            writeln!(
                output,
                r#"
#[test]
#[cfg_attr(feature = "isabelle-check", timeout(90000))]  // 90 seconds to allow for isabelle to verify
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn {fn_name}() {{
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join("{prefix}")
        .join("{escaped_name}");
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        "{escaped_name}",
        &{preconditions},
        "{lhs}",
        "{rhs}",
    );
    eq = eq.find_equivalence(None, Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}}
"#,
                fn_name = fn_name,
                escaped_name = case.name,
                preconditions = preconditions,
                lhs = case.lhs,
                rhs = case.rhs
            )
            .unwrap();
        }
    }
}
