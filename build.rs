use std::collections::BTreeMap;
use std::fs::{self, File};
use std::io::Write;
use std::path::{Path, PathBuf};

include!("src/types.rs");

fn sanitize_ident(s: &str) -> String {
    let mut out: String = s
        .chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect();
    // ensure it doesn't start with a digit
    if out
        .chars()
        .next()
        .map(|c| c.is_ascii_digit())
        .unwrap_or(false)
    {
        out.insert(0, '_');
    }
    // avoid empty
    if out.is_empty() {
        out = "_".to_string();
    }
    out
}

fn main() {
    let benchmarks_dir = Path::new("benchmarks");

    // Map subdir_name -> Vec<(file_stem, path)>
    let mut by_subdir: BTreeMap<String, Vec<(String, String)>> = BTreeMap::new();

    if let Ok(entries) = fs::read_dir(benchmarks_dir) {
        for entry in entries.flatten() {
            let subdir_path = entry.path();
            if subdir_path.is_dir() {
                if let Some(subdir_name) = subdir_path.file_name().and_then(|s| s.to_str()) {
                    if let Ok(sub_entries) = fs::read_dir(&subdir_path) {
                        for sub_entry in sub_entries.flatten() {
                            let file_path = sub_entry.path();
                            if file_path.extension().and_then(|s| s.to_str()) == Some("bwlang") {
                                if let Some(file_stem) =
                                    file_path.file_stem().and_then(|s| s.to_str())
                                {
                                    let path_str = file_path.to_string_lossy().into_owned();
                                    // Tell cargo to re-run when the benchmark file changes
                                    println!("cargo:rerun-if-changed={}", path_str);
                                    by_subdir
                                        .entry(subdir_name.to_string())
                                        .or_default()
                                        .push((file_stem.to_string(), path_str));
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Make sure tests directory exists
    let _ = fs::create_dir_all("tests");

    // For each subdir, create a single tests/<subdir>.rs containing all tests
    for (subdir, files) in by_subdir {
        if files.is_empty() {
            continue;
        }

        let out_path: PathBuf = format!("tests/{}.rs", subdir).into();
        let mut output = File::create(&out_path)
            .unwrap_or_else(|_| panic!("Failed to create output test file {:?}", out_path));

        // header + imports
        writeln!(output, "// AUTO-GENERATED BY build.rs\n").unwrap();
        writeln!(output, "use parabit::*;\n").unwrap(); // adjust crate name if needed
        writeln!(output, "use std::path::PathBuf;\n").unwrap();
        writeln!(output, "use ntest::timeout;\n").unwrap();

        // For each file in this subdir, parse the bwlang file and append a test fn
        for (file_stem, file_path) in files {
            let data = fs::read_to_string(&file_path)
                .unwrap_or_else(|_| panic!("Failed to read file {}", &file_path));
            let case: EquivalenceString = serde_json::from_str(&data)
                .unwrap_or_else(|e| panic!("Failed to parse JSON {}: {}", &file_path, e));

            // create a unique, safe function name
            let raw_fn_name = format!("{}_{}", subdir, case.name);
            let fn_name = sanitize_ident(&raw_fn_name);

            // Pretty-print preconditions and use debug formatting for string literals so they are valid Rust code
            let preconditions = format!("{:?}", case.preconditions);
            let name_literal = format!("{:?}", case.name);
            let lhs_literal = format!("{:?}", case.lhs);
            let rhs_literal = format!("{:?}", case.rhs);
            let prefix_literal = format!("{:?}", subdir); // used in output_dir join

            writeln!(
                output,
                r#"
#[test]
#[cfg_attr(not(feature = "isabelle-check"), timeout(30000))]
#[allow(non_snake_case)]
fn {fn_name}() {{
    let output_dir = PathBuf::from("target")
        .join("tests")
        .join({prefix_literal})
        .join({name_literal});
    prepare_output_dir(&output_dir, true);
    let mut eq = Equivalence::new(
        {name_literal},
        &{preconditions},
        {lhs_literal},
        {rhs_literal},
    );
    eq = eq.find_equivalence(&None, &Some(output_dir.clone()));
    assert!(eq.equiv.is_some_and(|x| x), "Equivalence was not found");
    eq.to_isabelle(&output_dir, true);
    #[cfg(feature = "isabelle-check")]
    eq.check_proof(&output_dir).unwrap();
}}
"#,
                fn_name = fn_name,
                prefix_literal = prefix_literal,
                name_literal = name_literal,
                preconditions = preconditions,
                lhs_literal = lhs_literal,
                rhs_literal = rhs_literal
            )
            .unwrap();
        }
    }
}
